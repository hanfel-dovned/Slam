<!DOCTYPE html>

<html>

<head>
	<title>Slam</title>
	<meta charset="utf-8">
	<style>
		* {
			margin: 0;
		}
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		canvas {
			display: block;
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
		}
	</style>
    
</head>

<body style="background-color:black;">

<script type="module">

import kaboom from "https://unpkg.com/kaboom/dist/kaboom.mjs";


function hsv2rgb(h,s,v) 
{                              
  let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
  return [f(5)*255,f(3)*255,f(1)*255];       
}   

//Send hiscore to gall agent
function hiscore(score) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'hiscore': score})
    })
}

//Send a new team to gall agent
//newteam([['foo', 'bar', '~hanfel'], ['foo2', 'bar2', '~minder']])
function newteam(team) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'new-team': team})
    }) 
}

//Send an invasion notification to gall agent
//invaded(['~zod', ['foo', 'bar', '~hanfel']])
function invaded(team) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'invaded': team})
    }) 
}

async function getprofiles() {
        const response = await fetch('/apps/slam/profiles')
        return response.json()
    }
var profiles = await getprofiles()

async function getmyship() {
        const response = await fetch('/apps/slam/whoami')
        return response.text()
    }
var myshipname = await getmyship()



const windowWidth = document.documentElement.clientWidth
const windowHeight = document.documentElement.clientHeight
const gameWidth = 1200
const gameHeight = 700
const scaleX = windowWidth / gameWidth
const scaleY = windowHeight / gameHeight 
const scaleGame = Math.min(scaleX, scaleY)

kaboom({
	//background: [ bgcolor[0], bgcolor[1], bgcolor[2] ],
    width: 1200,
    height: 700,
    scale: scaleGame,
    background: [0, 0, 50]
})


//try {loadSprite("ship", "https://api.urbit.live/images/" + myshipname + "_black.png")}
try {loadSprite("ship", "https://api.urbit.live/images/" + "hanfel-dovned" + "_black.png")}

catch {loadBean("ship")}

loadBean("playersprite")
loadBean("enemysprite")
        
loadSound("music", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/Slam-Gameplay-Song.mp3")
loadSound("intromusic", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/Slam-Intro-Song.mp3")

loadSound("explosion", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/explosion.wav")
loadSound("charge", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/charge.wav")
loadSound("slam", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/slam.wav")
loadSound("bump", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/bump.wav")
loadSound("dodge", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/dodge.wav")


scene("replay", () => {
	go("defend")
})


scene("sigil", () => {
    /*add([
		text("~hanfel-dovned presents", {font: "sinko", size: 40}),
		pos(width()*.5, height()*.3),
        origin("center"),
	])*/

    layers([
        "background",
        "foreground"
    ], "background")

    onDraw(() => {
        drawCircle({
            pos: vec2(width()*.5, height()*.5),
            radius: 100 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(width()*.5, height()*.5),
            width: 100 + Math.sin(time())*3, 
            height: 100 + Math.sin(time())*3,
            origin: "center"
        })
    })

    onMousePress(() => {
        go("title")
    })
})

function defendTransition(newscene) {
    go("defend")
}

function addButton(txt, p, f) {
    const btn = add([
        text(txt, {font: "sinko", size: 55}),
        pos(p),
        area({ cursor: "pointer", }),
        scale(1),
        origin("center"),
    ])

    btn.onClick(f)

    btn.onUpdate(() => {
        if (btn.isHovering()) {
            const t = time() * 2
            btn.color = rgb(
                wave(0, 255, t),
                wave(0, 255, t + 2),
                wave(0, 255, t + 4),
            )
            btn.scale = vec2(1.1)
        } else {
            btn.scale = vec2(1)
            btn.color = rgb()
        }
    })
}

scene("title", () => {

    layers([
        "background",
        "default"
    ], "default")

    play("dodge")

    var intromusic = play("intromusic", {loop: true})

	add([
		text("SLAM", {font: "sinko", size: 150}),
		pos(width()*.5, height()*.2),
        origin("center"),
	])
    
    onDraw(() => {
        drawCircle({
            pos: vec2(width()*.5, height()*.5),
            radius: 100 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(width()*.5, height()*.5),
            width: 100 + Math.sin(time())*3, 
            height: 100 + Math.sin(time())*3,
            origin: "center"
        })
    })

    addButton("Defend", vec2(width()*.35, height()*.75), () => {
        intromusic.stop()
        go("defend")
    })
    addButton("Invade", vec2(width()*.65, height()*.75), () => burp())
    addButton("Scores", vec2(width()*.5, height()*.87), () => burp())

    onUpdate(() => cursor("default"))

    for(var i = 0; i < 20; i++)
    {
        add([
            pos(rand(width()), rand(height())),
            layer("background"),
            origin("center"),
            {
                life: rand(1)
            },
            "titlecircle"
        ])
    }

    loop(.4, () => {
        add([
            pos(rand(width()), rand(height())),
            layer("background"),
            origin("center"),
            {
                life: 0
            },
            "titlecircle"
        ])
    })

    onDraw("titlecircle", (circle) => {
        circle.life += .001
        
        if(circle.life > 1)
            destroy(circle)

        drawCircle({
            pos: vec2(0),
            radius: circle.life*80,
            color: rgb(255, 255, 255),
            opacity: 1 - circle.life
        })
    })
})

scene("defend", () => {

    stop("intromusic")

    var music = play("music", {loop: true})

    var invadingpalpatp1 = Math.random()*255
    var invadingpalpatp2 = Math.random()*255
    
    var bghue = invadingpalpatp1 * 360/255
    var bgcolor = hsv2rgb(bghue, .75, .75)
        
    var gorasize = 50
    var score = 0
    var gameover = 0
    
    layers([
        "bg",
        "bgparticles",
        "ship",
        "game",
        "ui",
        "gameover"
    ], "game")
    
    var bgdrawer = add([
        layer("bg"),
        pos(-10, -10),
        {
            size: 500,
            color: hsv2rgb(bghue, .8, .4)
        }
    ])
    
    var colorcounter = 0
    bgdrawer.onDraw(() => {
        drawRect({
            pos: vec2(0),
            width: width() + 20,
            height: height() + 20,
            color: rgb(bgcolor[0] + colorcounter, bgcolor[1] + colorcounter, bgcolor[2] + colorcounter),
        })
        colorcounter = Math.sin(time()*2)*20
    })
    
    var scoreboard = add([
        layer("bg"),
        pos(width() - 100, rand(500, height() - 500)),
        {
            size: 500,
            color: hsv2rgb(bghue, .8, .4)
        }
    ])
    
    scoreboard.onUpdate(() => {
        scoreboard.pos.x -= .5
        if(scoreboard.pos.x < -scoreboard.size*2)
        {
            scoreboard.pos.x = width()
            scoreboard.pos.y = rand(scoreboard.size, height() - scoreboard.size)
        }
    })
    
    scoreboard.onDraw(() => {
        drawText({
    		text: score,
            font: "sink",
    		pos: vec2(0, 0),
    		origin: "left",
            size: scoreboard.size,
            color: rgb(scoreboard.color[0], scoreboard.color[1], scoreboard.color[2]),
            opacity: .1
    	})
    })

    var particlespawnx = 0;
    var particlespawny = 0;
    var particlemovex = 0;
    var particlemovey = 0;
    var particleshape = "";
    var particlespeed = 1
    loop(.4, () => {
    
        if(invadingpalpatp2 < 64)
        {
            particlespawnx = width() + 90
            particlespawny = rand(height())
            particlemovex = -particlespeed
            particlemovey = 0
        }
        else if(invadingpalpatp2 < 128)
        {
            particlespawnx = -90
            particlespawny = rand(height())
            particlemovex = particlespeed
            particlemovey = 0
        }
        else if(invadingpalpatp2 < 192)
        {
            particlespawnx = rand(width())
            particlespawny = height() + 90
            particlemovex = 0
            particlemovey = -particlespeed
        }
        else if(invadingpalpatp2 < 256)
        {
            particlespawnx = rand(width())
            particlespawny = -90
            particlemovex = 0
            particlemovey = particlespeed
        }
    
        if(invadingpalpatp2 % 2 == 0)
            particleshape = "square"
        else
            particleshape = "circle"
    
         add([
            pos(particlespawnx, particlespawny),
            layer("bgparticles"),
            origin("center"),
            {
                direction: 0,
                color: hsv2rgb(bghue, .8, .4),
                movex: particlemovex * rand(.3, 2),
                movey: particlemovey * rand(.3, 2),
                shape: particleshape
            },
            "backgroundparticle"
        ])
    
    })
    
    var mycolor = 0
    var drawcolor = 0
    var collideopacity = 0
    onDraw("backgroundparticle", (particle) => {
        particle.pos.x += particle.movex
        particle.pos.y += particle.movey
        
        if(particle.pos.x < -100 || particle.pos.x > width() + 100 || particle.pos.y < -100 || particle.pos.y > height() + 100)
            destroy(particle)
    
        if(particle.movey == 0)
            mycolor = rgb(particle.color[0] + particle.pos.x % 255, particle.color[1] + particle.pos.x % 255, particle.color[2] + particle.pos.x % 255)
        else if(particle.movex == 0)
            mycolor = rgb(particle.color[0] + particle.pos.y % 255, particle.color[1] + particle.pos.y % 255, particle.color[2] + particle.pos.y % 255)
        
        drawRect({
            pos: vec2(0),
            width: 80,
            height: 80,
            color: mycolor,
            opacity: .15
        })
    })
    
    
    /**************** PLAYER ****************/
    var player = add([
    	sprite("playersprite", {width: gorasize, height: gorasize}),
        //scale(.7, .7),
    	pos(width()/2, height()/2 - 100),
    	area(),
        layer("game"),
        origin("center"),
        {
            charging: 0,
            slamming: 0,
            slamdirection: 0,
            
            slamspeed: 2500,
    
            //charge impacts the distance/duration of slamming
            //slamming speed is constant regardless of charge level
            charge: 0,
            maxcharge: 120,
            chargerate: 5,
            chargeloss: 15,
            movespeed: 400,
            attacked: 0
        },
        "player"
    ])
    
    //Mouse Controls - Charging and Slamming
    onMousePress(() => {
        player.charging = 1
        if(gameover == 0)
            play("charge", {volume: .5})
    })
    
    onMouseDown(() => {
        if(player.charge < player.maxcharge && player.charging == 1)
            player.charge += player.chargerate;
        player.move(Vec2.fromAngle(rand(360)).scale(30))
    })
    
    onMouseRelease(() => {
        if(player.charging == 1)
        {
            player.charging = 0;
            player.slamming = 1;
            player.slamdirection = player.pos.angle(mousePos())
            player.color = rgb()
            player.slamspeed = player.charge * 10
            player.charge = 0
            if(gameover == 0)
                play("slam", {volume: .5})
        }
    })
    
    player.onUpdate(() => {
        //Loop around edge of screen
        if(player.pos.x < 0)
            player.pos.x = 0
        if(player.pos.x > width())
            player.pos.x = width()
        if(player.pos.y < 0)
            player.pos.y = 0
        if(player.pos.y > height())
            player.pos.y = height()
    
        if(player.slamming == 1)
        {
            player.move(Vec2.fromAngle(player.slamdirection).scale(-player.slamspeed))
            player.slamspeed -= 20
    
            if(player.slamspeed <= 0)
                player.slamming = 0;
        }
    
        if(player.attacked > 0)
        {
            player.moveTo(width()/2, height()/2, player.attacked * 100)
            player.attacked -= 1
        }
    })
    
    player.onCollide("enemy", (enemy) => {
        if(player.slamming == 1)
        {
            enemy.direction = player.slamdirection

            player.slamdirection = player.slamdirection + 180
            enemy.charge = player.slamspeed
    	    player.slamspeed = player.slamspeed * .5
            enemy.attacked = 1
            if(gameover == 0)
            {
                shake(5)
                play("bump", {volume: .5})
            }
            collideopacity = 1
        }
        else
        {
            player.attacked = 10
            enemy.moveTo(width()/2, height()/2, -1000)
            if(gameover == 0)
            {
                shake(5)
                play("bump", {volume: .5})
            }
            collideopacity = 1
        }
    })
    
    
    //Draw the black circle around the gora sprite
    var goraBackground = rgb(0, 0, 0)
    player.onDraw(() => {
        goraBackground = rgb(player.charge*(255/player.maxcharge), 0, 0)
        drawCircle({
            pos: vec2(0),
            radius: gorasize*.8 + player.charge/player.maxcharge*5,
            color: goraBackground,
            outline: {width: 1, color: rgb(0, 0, 0)}
        })
        /*drawSprite({
            sprite: "player",
            pos: vec2(0),
            width: gorasize, 
            height: gorasize,
            origin: "center"
        })*/
    })
    
    
    
    /**************** ENEMY ****************/
    var tempsprite = "player"
    
    
    var spawnpositionx = -20
    var spawnpositiony = -20
    var spawnseed = 0
    
    var invasionspeed = 1
    var spawntime = 3
    var wavesize = 1
    
    var enemysprite = "enemysprite"
    
    var issuer = 0
    var pal = 0
    var hue = 0
    var weight = 0
    var size = 0
    var invasionspeed = 0
    
    loop(2, () => {
    
        //enemysprite = "enemy" + Math.ceil(rand(6))
    
        issuer = rand(255)
        pal = rand(255)
        hue = pal * 360/255
        
        weight = issuer/255
        size = gorasize + (gorasize * (weight-.5))
        invasionspeed = 1 - weight
    
        
        spawnseed = rand(4)
        if(spawnseed < 1)
        {
            spawnpositionx = -100
            spawnpositiony = rand(height())
        }
        else if(spawnseed < 2)
        {
            spawnpositionx = width() + 100
            spawnpositiony = rand(height())
        }
        else if(spawnseed < 3)
        {
            spawnpositionx = rand(width())
            spawnpositiony = -100
        }
        else if(spawnseed < 4)
        {
            spawnpositionx = rand(width())
            spawnpositiony = height() + 100
        }
    
        if(gameover == 0)
        {
            add([
                sprite(enemysprite, {width: size, height: size}),
                pos(spawnpositionx, spawnpositiony),
                //move(ship.pos.angle(pos), 12),
                area({scale: 1.2}),
                origin("center"),
                layer("game"),
                //color = rgb(100, 100, 0),
                {
                    direction: 0,
                    charge: 0,
                    attacked: 0,
                    death: 0,
                    deathglow: 0,
                    issuer: issuer,
                    invasionspeed: invasionspeed,
                    weight: weight,
                    size: size,
                    pal: pal,
                    color: hsv2rgb(hue, 1, 1 - weight*.7),
                    sprite: enemysprite,
                },
                "enemy"
            ])
        }
    })
    
    var buffer = gorasize*.8
    onUpdate("enemy", (enemy) => {
        //Enemies die when they hit the edge of the screen
        if(enemy.pos.x > width() + buffer || enemy.pos.x < -buffer || enemy.pos.y > height() + buffer || enemy.pos.y < -buffer)
        {
            if(enemy.attacked == 1)
            {
                destroy(enemy)
                play("explosion")
                if(gameover == 0)
                    score += 1
            }
        }
    
        //Death Animation
        if(enemy.death == 1)
        {
            if(enemy.deathglow > 255)
            {   
                destroy(enemy)
                play("explosion")
                score += 1
            }
            
            enemy.deathglow += 50
            enemy.scale = 1 + enemy.deathglow/250
        }
        
        if(enemy.attacked == 1 && enemy.death == 0)
        {
    
            enemy.move(Vec2.fromAngle(enemy.direction).scale(-enemy.charge))
            //enemy.charge -= 0
            enemy.charge -= enemy.weight*100 //make this weight
                
            if(enemy.charge <= 0)
            {
                enemy.attacked = 0;
                enemy.charge = 0;
            }
        }
        else if(enemy.death == 0)
        {
           // if(!enemy.isColliding(player)) 
                enemy.moveTo(width()/2, height()/2, enemy.invasionspeed*200)
            //else
            //    enemy.moveTo(width()/2, height()/2, 2000)
        }
    })
    
    onCollide("enemy", "enemy", (enemy1, enemy2) => {
        enemy1.death = 1
        enemy2.death = 1
    })
    
    onDraw("enemy", (enemy) => {
        drawcolor = rgb(enemy.color[0], enemy.color[1], enemy.color[2])
        
        drawCircle({
            pos: vec2(0),
            radius: enemy.size*.8 + Math.sin(time()*500/enemy.size),
            color: drawcolor,
            outline: {width: 1, color: rgb(0, 0, 0)}
        })
        drawSprite({
            sprite: enemy.sprite,
            pos: vec2(0),
            width: enemy.size, 
            height: enemy.size,
            origin: "center"
        })
        
        if(enemy.deathglow > 100)
        {   
            drawCircle({
                pos: vec2(0),
                radius: enemy.size,
                color: rgb(255, 255, 255),
            })
        }
    })
    
    
    
    var ship = add([
    	sprite("ship", {width: gorasize*1.2, height: gorasize*1.2}),
        //scale(.7, .7),
    	pos(width()/2, height()/2),
    	area(),
        origin("center"),
        layer("ship")
    ])
    
    ship.onDraw(() => {
        drawCircle({
            pos: vec2(0),
            radius: gorasize*1.2*.8 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(0),
            width: gorasize*1.2*.8 + Math.sin(time())*3, 
            height: gorasize*1.2*.8 + Math.sin(time())*3,
            origin: "center"
        })
    })
    
    var gameoverenemypos = vec2(0)
    var gameoverenemysize = 0
    
    ship.onCollide("enemy", (enemy) => {
        if(gameover == 0 && enemy.death == 0)
        {
            play("explosion")
            music.stop()
            gameover = 1
            gameoverenemypos = enemy.pos 
            gameoverenemysize = enemy.size
            destroyAll("enemy")
        }
    })
    
    var gameoverdrawer = add([
        layer("gameover"),
        pos(0, 0)
    ])
    
    var scoreopacity = -1
    gameoverdrawer.onDraw(() => {
        if(gameover == 1)
        {
            drawRect({
                pos: vec2(-20, -20),
                width: width() + 40,
                height: height() + 40,
                color: rgb(255, 255, 255),
            })
            drawCircle({
                pos: center(),
                radius: gorasize*.8+3,
                color: rgb(0,0,0)
            })
            drawSprite({
                sprite: "ship",
                pos: center(),
                origin: "center",
                width: gorasize,
                height: gorasize
            })
            
            drawCircle({
                pos: gameoverenemypos,
                radius: gameoverenemysize*.8,
                color: rgb(0, 0, 0),
            })
    
            drawText({
        		text: score,
                font: "sink",
        		pos: vec2(width()*.5, height()*.25),
        		origin: "center",
                size: scoreboard.size*.25,
                color: rgb(0, 0, 0),
                opacity: scoreopacity
    	    })
            drawRect({
                pos: vec2(0, height()*.33),
                width: width(),
                height: 10,
                color: rgb(255, 255, 255),
            })
    
            if(scoreopacity < 1)
                scoreopacity += .01
    
        }

        onMousePress(() => {
            if(gameover == 1)
            {
                go("replay")
                //music.play()
            }
        })
    
    })
})

go("sigil");

</script>

</body>

</html>