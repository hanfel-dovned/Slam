<!DOCTYPE html>

<html>

<head>
	<title>Slam</title>
	<meta charset="utf-8">
	<style>
		* {
			margin: 0;
		}
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		canvas {
			display: block;
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
		}
	</style>
    
</head>

<body style="background-color:black;">

<script type="module">

import kaboom from "https://unpkg.com/kaboom/dist/kaboom.mjs";


function hsv2rgb(h,s,v) 
{                              
  let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
  return [f(5)*255,f(3)*255,f(1)*255];       
}   

//Send hiscore to gall agent
function hiscore(score) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'hiscore': score})
    })
}

//Send a new team to gall agent
//newteam([['foo', 'bar', '~hanfel'], ['foo2', 'bar2', '~minder']])
function newteam(team) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'new-team': team})
    }) 
}

//Send an invasion notification to gall agent
//invaded(['~zod', ['foo', 'bar', '~hanfel']])
//actually, just invaded('~zod') hopefully
function invaded(team) {
    fetch('/apps/slam', {
        method: 'POST',
        body: JSON.stringify({'invaded': team})
    }) 
}

async function getprofiles() {
        const response = await fetch('/apps/slam/profiles')
        return response.json()
    }
//var profiles = await getprofiles()

var profiles = {'~palfun-foslup': [10, 12, [['hello', 'http://www.thebestdinosaur.com/best-stegosaurus.png', '~minder'], ['hello2', 'http://www.thebestdinosaur.com/best-stegosaurus.png', '~minder-folden']]],
                '~hanfel-dovned': [6, 3, [['mygora', 'https://noah.hanfeldovned.repl.co/noah.jpg', '~zod'], ['mygora2', 'https://noah.hanfeldovned.repl.co/noah.jpg', '~littel-wolfur']]],
                '~minder-folden': [0, 35, [['firstg', 'https://raw.githubusercontent.com/sigilante/hsl-2022.02/master/gora-hsl-~2022.2.png', '~zod'], ['mygora2', 'https://noah.hanfeldovned.repl.co/noah.jpg', '~littel-wolfur']]],
}

async function getmyship() {
        const response = await fetch('/apps/slam/whoami')
        return response.text()
    }
var myshipname = await getmyship()

function playSoundSafe(sound, vol = 1) {
    try {play(sound, {volume: vol})}
    catch {}
}



const windowWidth = document.documentElement.clientWidth
const windowHeight = document.documentElement.clientHeight
const gameWidth = 1200
const gameHeight = 700
const scaleX = windowWidth / gameWidth
const scaleY = windowHeight / gameHeight 
const scaleGame = Math.min(scaleX, scaleY)

kaboom({
	//background: [ bgcolor[0], bgcolor[1], bgcolor[2] ],
    width: 1200,
    height: 700,
    scale: scaleGame,
    background: [0, 0, 50]
})


try {loadSprite("ship", "https://api.urbit.live/images/" + myshipname + "_black.png")}
catch {loadBean("ship")}

loadBean("playersprite")
loadBean("enemysprite")
        
loadSound("music", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/Slam-Gameplay-Song.mp3")
loadSound("intromusic", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/Slam-Intro-Song.mp3")

loadSound("explosion", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/explosion.wav")
loadSound("charge", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/charge.wav")
loadSound("slam", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/slam.wav")
loadSound("bump", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/bump.wav")
loadSound("dodge", "https://hanfel-dovned.sfo3.digitaloceanspaces.com/dodge.wav")


scene("replay", () => {
	go("defend")
})


scene("sigil", () => {
    /*add([
		text("~hanfel-dovned presents", {font: "sinko", size: 40}),
		pos(width()*.5, height()*.3),
        origin("center"),
	])*/

    layers([
        "background",
        "foreground"
    ], "background")

    onDraw(() => {
        drawCircle({
            pos: vec2(width()*.5, height()*.5),
            radius: 100 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(width()*.5, height()*.5),
            width: 100 + Math.sin(time())*3, 
            height: 100 + Math.sin(time())*3,
            origin: "center"
        })
    })

    onMousePress(() => {
        go("title")
    })
})

function defendTransition(newscene) {
    go("defend")
}

function addButton(txt, p, f) {
    const btn = add([
        text(txt, {font: "sinko", size: 55}),
        pos(p),
        area({ cursor: "default", }),
        scale(1),
        origin("center"),
    ])

    btn.onClick(f)

    btn.onUpdate(() => {
        if (btn.isHovering()) {
            const t = time() * 2
            btn.color = rgb(
                wave(0, 255, t),
                wave(0, 255, t + 2),
                wave(0, 255, t + 4),
            )
            btn.scale = vec2(1.1)
        } else {
            btn.scale = vec2(1)
            btn.color = rgb()
        }
    })
}

var intromusic;
var isPlaying = 0;

function playIntroMusic() {
    if(isPlaying == 0)
    {
        try{intromusic = play("intromusic", {loop: true})}
        catch{intromusic = 0}
    }

    isPlaying = 1;
}

function stopIntroMusic() {
    try{intromusic.stop()}
    catch{}

    isPlaying = 0;
}

scene("title", () => {

    playIntroMusic()
        
    layers([
        "background",
        "default",
        "transition"
    ], "default")

    playSoundSafe("dodge")

    

	add([
		text("SLAM", {font: "sinko", size: 150}),
		pos(width()*.5, height()*.2),
        origin("center"),
	])
    
    var shipdrawer = add([
        layer("default"),
        pos(0, 0)
    ])

    shipdrawer.onDraw(() => {
        drawCircle({
            pos: vec2(width()*.5, height()*.5),
            radius: 100 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(width()*.5, height()*.5),
            width: 100 + Math.sin(time())*3, 
            height: 100 + Math.sin(time())*3,
            origin: "center"
        })
    })

    addButton("Play", vec2(width()*.5, height()*.71), () => {
        transition = 1;
    })
    addButton("Invaders", vec2(width()*.5, height()*.82), () => burp())
    addButton("Scores", vec2(width()*.5, height()*.93), () => go("scores"))

    onUpdate(() => cursor("default"))

    for(var i = 0; i < 20; i++)
    {
        add([
            pos(rand(width()), rand(height())),
            layer("background"),
            origin("center"),
            {
                life: rand(1)
            },
            "titlecircle"
        ])
    }

    loop(.4, () => {
        add([
            pos(rand(width()), rand(height())),
            layer("background"),
            origin("center"),
            {
                life: 0
            },
            "titlecircle"
        ])
    })

    onDraw("titlecircle", (circle) => {
        circle.life += .001
        
        if(circle.life > 1)
            destroy(circle)

        drawCircle({
            pos: vec2(0),
            radius: circle.life*80,
            color: rgb(255, 255, 255),
            opacity: 1 - circle.life
        })
    })

    var transitiondrawer = add([
        layer("transition"),
        pos(0, 0)
    ])
    
    var transitionopacity = 0
    var transition = 0
    transitiondrawer.onDraw(() => {
        if(transition == 1)
        {
            drawRect({
                pos: vec2(-20, -20),
                width: width() + 40,
                height: height() + 40,
                color: rgb(0, 0, 0),
                opacity: transitionopacity
            })
            if(transitionopacity < 1)
            {
                transitionopacity += .02
                volume(1 - transitionopacity)
            }
            else
            {
                stopIntroMusic()                
                go("defend")
            }
        }
    })
})

function drawScores() {
    let highscores = []
    let invadescores = []

    for (var key in profiles) {
        highscores.push([key, profiles[key][0]])
        invadescores.push([key, profiles[key][1]])
    }

    highscores.sort(function(a, b) {
        return b[1] - a[1];
    })

    invadescores.sort(function(a, b) {
        return b[1] - a[1];
    })

    add([
        text("High Score", {font: "sinko", size: 50}),
        pos(width()*.1, height()*.1),
        origin("left"),
    ])
    for(var i = 0; i < highscores.length; i++)
    {
        add([
            text(highscores[i], {font: "sinko", size: 30}),
            pos(width()*.1, height()*.18 + i * 40),
            origin("left"),
        ])
    }

    add([
        text("Invasions", {font: "sinko", size: 50}),
        pos(width()*.9, height()*.1),
        origin("right"),
    ])
    for(var i = 0; i < invadescores.length; i++)
    {
        add([
            text(invadescores[i], {font: "sinko", size: 30}),
            pos(width()*.9, height()*.18 + i * 40),
            origin("right"),
        ])
    }
}


scene("scores", () => {
   playSoundSafe("dodge")
   drawScores()
   addButton("Back", vec2(width()*.5, height()*.93), () => go("title"))
})

scene("defend", () => {

    volume(1)

    try{var music = play("music", {loop: true})}
    catch{var music = 0}

    var invadingpalpatp1 = Math.random()*255
    var invadingpalpatp2 = Math.random()*255
    
    var bghue = invadingpalpatp1 * 360/255
    var bgcolor = hsv2rgb(bghue, .75, .75)
        
    var gorasize = 50
    var score = 0
    var gameover = 0
    
    layers([
        "bg",
        "bgparticles",
        "ship",
        "game",
        "ui",
        "gameover"
    ], "game")

    var transitiondrawer = add([
        layer("gameover"),
        pos(0, 0)
    ])
    
    var transitionopacity = 1
    transitiondrawer.onDraw(() => {
            drawRect({
                pos: vec2(-20, -20),
                width: width() + 40,
                height: height() + 40,
                color: rgb(0, 0, 0),
                opacity: transitionopacity
            })
            
            transitionopacity -= .1
            if(transitionopacity <= 0)
                destroy()
    })
    
    var bgdrawer = add([
        layer("bg"),
        pos(-10, -10),
        {
            size: 500,
            color: hsv2rgb(bghue, .8, .4)
        }
    ])
    
    var colorcounter = 0
    bgdrawer.onDraw(() => {
        drawRect({
            pos: vec2(0),
            width: width() + 20,
            height: height() + 20,
            color: rgb(bgcolor[0] + colorcounter, bgcolor[1] + colorcounter, bgcolor[2] + colorcounter),
        })
        colorcounter = Math.sin(time()*2)*20
    })
    
    var scoreboard = add([
        layer("bg"),
        pos(width() - 100, rand(500, height() - 500)),
        {
            size: 500,
            color: hsv2rgb(bghue, .8, .4)
        }
    ])
    
    scoreboard.onUpdate(() => {
        scoreboard.pos.x -= .5
        if(scoreboard.pos.x < -scoreboard.size*2)
        {
            scoreboard.pos.x = width()
            scoreboard.pos.y = rand(scoreboard.size, height() - scoreboard.size)
        }
    })
    
    scoreboard.onDraw(() => {
        drawText({
    		text: score,
            font: "sink",
    		pos: vec2(0, 0),
    		origin: "left",
            size: scoreboard.size,
            color: rgb(scoreboard.color[0], scoreboard.color[1], scoreboard.color[2]),
            opacity: .1
    	})
    })

    var particlespawnx = 0;
    var particlespawny = 0;
    var particlemovex = 0;
    var particlemovey = 0;
    var particleshape = "";
    var particlespeed = 1
    loop(.4, () => {
    
        if(invadingpalpatp2 < 64)
        {
            particlespawnx = width() + 90
            particlespawny = rand(height())
            particlemovex = -particlespeed
            particlemovey = 0
        }
        else if(invadingpalpatp2 < 128)
        {
            particlespawnx = -90
            particlespawny = rand(height())
            particlemovex = particlespeed
            particlemovey = 0
        }
        else if(invadingpalpatp2 < 192)
        {
            particlespawnx = rand(width())
            particlespawny = height() + 90
            particlemovex = 0
            particlemovey = -particlespeed
        }
        else if(invadingpalpatp2 < 256)
        {
            particlespawnx = rand(width())
            particlespawny = -90
            particlemovex = 0
            particlemovey = particlespeed
        }
    
        if(invadingpalpatp2 % 2 == 0)
            particleshape = "square"
        else
            particleshape = "circle"
    
         add([
            pos(particlespawnx, particlespawny),
            layer("bgparticles"),
            origin("center"),
            {
                direction: 0,
                color: hsv2rgb(bghue, .8, .4),
                movex: particlemovex * rand(.3, 2),
                movey: particlemovey * rand(.3, 2),
                shape: particleshape
            },
            "backgroundparticle"
        ])
    
    })
    
    var mycolor = 0
    var drawcolor = 0
    var collideopacity = 0
    onDraw("backgroundparticle", (particle) => {
        particle.pos.x += particle.movex
        particle.pos.y += particle.movey
        
        if(particle.pos.x < -100 || particle.pos.x > width() + 100 || particle.pos.y < -100 || particle.pos.y > height() + 100)
            destroy(particle)
    
        if(particle.movey == 0)
            mycolor = rgb(particle.color[0] + particle.pos.x % 255, particle.color[1] + particle.pos.x % 255, particle.color[2] + particle.pos.x % 255)
        else if(particle.movex == 0)
            mycolor = rgb(particle.color[0] + particle.pos.y % 255, particle.color[1] + particle.pos.y % 255, particle.color[2] + particle.pos.y % 255)
        
        drawRect({
            pos: vec2(0),
            width: 80,
            height: 80,
            color: mycolor,
            opacity: .15
        })
    })
    
    
    /**************** PLAYER ****************/
    var player = add([
    	sprite("playersprite", {width: gorasize, height: gorasize}),
        //scale(.7, .7),
    	pos(width()/2, height()/2 - 100),
    	area(),
        layer("game"),
        origin("center"),
        {
            charging: 0,
            slamming: 0,
            slamdirection: 0,
            
            slamspeed: 2500,
    
            //charge impacts the distance/duration of slamming
            //slamming speed is constant regardless of charge level
            charge: 0,
            maxcharge: 120,
            chargerate: 5,
            chargeloss: 15,
            movespeed: 400,
            attacked: 0
        },
        "player"
    ])
    
    //Mouse Controls - Charging and Slamming
    onMousePress(() => {
        player.charging = 1
        if(gameover == 0)
            playSoundSafe("charge", .5)
    })
    
    onMouseDown(() => {
        if(player.charge < player.maxcharge && player.charging == 1)
            player.charge += player.chargerate;
        player.move(Vec2.fromAngle(rand(360)).scale(30))

        if(rand(4) < 1)
        {
            add([
                pos(player.pos.x, player.pos.y),
                layer("bgparticles"),
                {
                    size: rand(13),
                    direction: rand(360),
                    speed: 300 + rand(50),
                    life: 30
                },
                "chargeparticle"
            ])
        }
    })

    onDraw("chargeparticle", (particle) => {
        drawRect({
            pos: vec2(0, 0),
            width: particle.size,
            height: particle.size,
            color: rgb(255, 255, 255),
            opacity: .3
        })
        particle.move(Vec2.fromAngle(particle.direction).scale(-particle.speed))
        particle.life -= 1
        if(particle.life <= 0)
            destroy(particle)
    })

    
    onMouseRelease(() => {
        if(player.charging == 1)
        {
            player.charging = 0;
            player.slamming = 1;
            player.slamdirection = player.pos.angle(mousePos())
            player.color = rgb()
            player.slamspeed = player.charge * 10
            player.charge = 0
            if(gameover == 0)
                playSoundSafe("slam", .5)
        }
    })
    
    player.onUpdate(() => {
        //Loop around edge of screen
        if(player.pos.x < 0)
            player.pos.x = 0
        if(player.pos.x > width())
            player.pos.x = width()
        if(player.pos.y < 0)
            player.pos.y = 0
        if(player.pos.y > height())
            player.pos.y = height()
    
        if(player.slamming == 1)
        {
            player.move(Vec2.fromAngle(player.slamdirection).scale(-player.slamspeed))
            player.slamspeed -= 20
    
            if(player.slamspeed <= 0)
                player.slamming = 0;

            add([
                pos(player.pos.x, player.pos.y),
                layer("bgparticles"),
                {
                    size: 10,
                    life: 30
                },
                "trailparticle"
            ])
        }
    
        if(player.attacked > 0)
        {
            player.moveTo(width()/2, height()/2, player.attacked * 100)
            player.attacked -= 1
        }
    })

    onDraw("trailparticle", (particle) => {
        drawRect({
            pos: vec2(0, 0),
            width: particle.size,
            height: particle.size,
            color: rgb(255, 255, 255),
            opacity: particle.life/120
        })
        particle.life -= 1
        if(particle.life <= 0)
            destroy(particle)
    })
    
    
    player.onCollide("enemy", (enemy) => {
        if(player.slamming == 1)
        {
            enemy.direction = player.slamdirection

            player.slamdirection = player.slamdirection + 180
            enemy.charge = player.slamspeed
    	    player.slamspeed = player.slamspeed * .5
            enemy.attacked = 1
            if(gameover == 0)
            {
                shake(5)
                playSoundSafe("bump", .5)
            }
            collideopacity = 1

            for(var i = 0; i < 8; i++)
            {
                add([
                    pos(enemy.pos.x, enemy.pos.y),
                    layer("bgparticles"),
                    {
                        size: rand(13) + 5,
                        direction: rand(360),
                        speed: 600 + rand(100),
                        life: 15
                    },
                    "slamparticle"
                ])
            }
        }
        else
        {
            player.attacked = 10
            enemy.moveTo(width()/2, height()/2, -1000)
            if(gameover == 0)
            {
                shake(5)
                playSoundSafe("bump", .5)
            }
            collideopacity = 1
        }
    })

    onDraw("slamparticle", (particle) => {
        drawRect({
            pos: vec2(0, 0),
            width: particle.size,
            height: particle.size,
            color: rgb(0, 0, 0),
            opacity: .2
        })
        particle.move(Vec2.fromAngle(particle.direction).scale(-particle.speed))
        particle.life -= 1
        if(particle.life <= 0)
            destroy(particle)
    })
    
    
    //Draw the black circle around the gora sprite
    var goraBackground = rgb(0, 0, 0)
    player.onDraw(() => {
        goraBackground = rgb(player.charge*(255/player.maxcharge), 0, 0)
        drawCircle({
            pos: vec2(0),
            radius: gorasize*.8 + player.charge/player.maxcharge*5,
            color: goraBackground,
            outline: {width: 1, color: rgb(0, 0, 0)}
        })
        drawPolygon({
            pts: [
                vec2(0, -gorasize*.5),
                vec2(-gorasize*.45, gorasize*.3),
                vec2(gorasize*.45, gorasize*.3),
            ],
            pos: vec2(0),
            color: rgb(255, 255, 255),
            outline: {width: 1, color: rgb(0, 0, 0)}
        })
    })
    
    
    
    /**************** ENEMY ****************/
    var tempsprite = "player"
    
    
    var spawnpositionx = -20
    var spawnpositiony = -20
    var spawnseed = 0
    
    var invasionspeed = 1
    var spawntime = 3
    var wavesize = 1
    
    var enemysprite = "enemysprite"
    
    var issuer = 0
    var pal = 0
    var hue = 0
    var weight = 0
    var size = 0
    var invasionspeed = 0
    
    loop(2, () => {
    
        //enemysprite = "enemy" + Math.ceil(rand(6))
    
        issuer = rand(255)
        pal = rand(255)
        hue = pal * 360/255
        
        weight = issuer/255
        size = gorasize + (gorasize * (weight-.5))
        invasionspeed = 1 - weight
    
        
        spawnseed = rand(4)
        if(spawnseed < 1)
        {
            spawnpositionx = -100
            spawnpositiony = rand(height())
        }
        else if(spawnseed < 2)
        {
            spawnpositionx = width() + 100
            spawnpositiony = rand(height())
        }
        else if(spawnseed < 3)
        {
            spawnpositionx = rand(width())
            spawnpositiony = -100
        }
        else if(spawnseed < 4)
        {
            spawnpositionx = rand(width())
            spawnpositiony = height() + 100
        }
    
        if(gameover == 0)
        {
            add([
                sprite(enemysprite, {width: size, height: size}),
                pos(spawnpositionx, spawnpositiony),
                //move(ship.pos.angle(pos), 12),
                area({scale: 1.2}),
                origin("center"),
                layer("game"),
                //color = rgb(100, 100, 0),
                {
                    direction: 0,
                    charge: 0,
                    attacked: 0,
                    death: 0,
                    deathglow: 0,
                    issuer: issuer,
                    invasionspeed: invasionspeed,
                    weight: weight,
                    size: size,
                    pal: pal,
                    color: hsv2rgb(hue, 1, 1 - weight*.7),
                    sprite: enemysprite,
                },
                "enemy"
            ])
        }
    })
    
    var buffer = gorasize*.8
    onUpdate("enemy", (enemy) => {
        //Enemies die when they hit the edge of the screen
        if(enemy.pos.x > width() + buffer || enemy.pos.x < -buffer || enemy.pos.y > height() + buffer || enemy.pos.y < -buffer)
        {
            if(enemy.attacked == 1)
            {
                destroy(enemy)
                playSoundSafe("explosion")
                if(gameover == 0)
                    score += 1

                for(var i = 0; i < 20; i++)
                {
                    add([
                        pos(enemy.pos.x, enemy.pos.y),
                        layer("bgparticles"),
                        {
                            size: rand(15) + 10,
                            direction: rand(360),
                            speed: 800 + rand(100),
                            life: 15
                        },
                        "explodeparticle"
                    ])
                }
            }
        }
    
        //Death Animation
        if(enemy.death == 1)
        {
            if(enemy.deathglow > 255)
            {   
                destroy(enemy)
                playSoundSafe("explosion")
                score += 1

                for(var i = 0; i < 20; i++)
                {
                    add([
                        pos(enemy.pos.x, enemy.pos.y),
                        layer("bgparticles"),
                        {
                            size: rand(15) + 10,
                            direction: rand(360),
                            speed: 800 + rand(100),
                            life: 15
                        },
                        "explodeparticle"
                    ])
                }
            }
            
            enemy.deathglow += 50
            enemy.scale = 1 + enemy.deathglow/250
        }
        
        if(enemy.attacked == 1 && enemy.death == 0)
        {
    
            enemy.move(Vec2.fromAngle(enemy.direction).scale(-enemy.charge))
            //enemy.charge -= 0
            enemy.charge -= enemy.weight*100 //make this weight
                
            if(enemy.charge <= 0)
            {
                enemy.attacked = 0;
                enemy.charge = 0;
            }
        }
        else if(enemy.death == 0)
        {
           // if(!enemy.isColliding(player)) 
                enemy.moveTo(width()/2, height()/2, enemy.invasionspeed*200)
            //else
            //    enemy.moveTo(width()/2, height()/2, 2000)
        }
    })
    

    onDraw("explodeparticle", (particle) => {
        drawRect({
            pos: vec2(0, 0),
            width: particle.size,
            height: particle.size,
            color: rgb(255, 255, 255),
            opacity: .35
        })
        particle.move(Vec2.fromAngle(particle.direction).scale(-particle.speed))
        particle.life -= 1
        if(particle.life <= 0)
            destroy(particle)
    })

    onCollide("enemy", "enemy", (enemy1, enemy2) => {
        enemy1.death = 1
        enemy2.death = 1
    })
    
    onDraw("enemy", (enemy) => {
        drawcolor = rgb(enemy.color[0], enemy.color[1], enemy.color[2])
        
        drawCircle({
            pos: vec2(0),
            radius: enemy.size*.8 + Math.sin(time()*500/enemy.size),
            color: drawcolor,
            outline: {width: 1, color: rgb(0, 0, 0)}
        })
        drawSprite({
            sprite: enemy.sprite,
            pos: vec2(0),
            width: enemy.size, 
            height: enemy.size,
            origin: "center"
        })
        
        if(enemy.deathglow > 100)
        {   
            drawCircle({
                pos: vec2(0),
                radius: enemy.size,
                color: rgb(255, 255, 255),
            })
        }
    })
    
    
    
    var ship = add([
    	sprite("ship", {width: gorasize*1.2, height: gorasize*1.2}),
        //scale(.7, .7),
    	pos(width()/2, height()/2),
    	area(),
        origin("center"),
        layer("ship")
    ])
    
    ship.onDraw(() => {
        drawCircle({
            pos: vec2(0),
            radius: gorasize*1.2*.8 + Math.sin(time())*3,
            color: rgb(0,0,0)
        })
        drawSprite({
            sprite: "ship",
            pos: vec2(0),
            width: gorasize*1.2*.8 + Math.sin(time())*3, 
            height: gorasize*1.2*.8 + Math.sin(time())*3,
            origin: "center"
        })
    })
    
    var gameoverenemypos = vec2(0)
    var gameoverenemysize = 0

    function addButtonReplay(txt, p, f) {
        const btn = add([
            text(txt, {font: "sink", size: 30}),
            layer("gameover"),
            pos(p),
            area(),
            scale(1),
            origin("center"),
        ])

        btn.onClick(f)

        btn.onUpdate(() => {
            if (btn.isHovering()) {
                const t = time() * 2
                btn.color = rgb(
                    wave(0, 255, t),
                    wave(0, 255, t + 2),
                    wave(0, 255, t + 4),
                )
                btn.scale = vec2(1.1)
            } else {
                btn.scale = vec2(1)
                btn.color = rgb(0, 0, 0)
            }
        })
    }
    
    ship.onCollide("enemy", (enemy) => {
        if(gameover == 0 && enemy.death == 0)
        {
            playSoundSafe("explosion")
            try {music.stop()}
            catch {}
            gameover = 1
            gameoverenemypos = enemy.pos 
            gameoverenemysize = enemy.size
            destroyAll("enemy")
            addButtonReplay("Replay", vec2(width()*.5, height()*.82), () => go("replay"))
            addButtonReplay("Menu", vec2(width()*.5, height()*.9), () => go("title"))
        }
    })
    
    var gameoverdrawer = add([
        layer("gameover"),
        pos(0, 0)
    ])
    
    var scoreopacity = 1
    gameoverdrawer.onDraw(() => {
        if(gameover == 1)
        {
            drawRect({
                pos: vec2(-20, -20),
                width: width() + 40,
                height: height() + 40,
                color: rgb(255, 255, 255),
            })
            drawCircle({
                pos: center(),
                radius: gorasize*.8+3,
                color: rgb(0,0,0)
            })
            drawSprite({
                sprite: "ship",
                pos: center(),
                origin: "center",
                width: gorasize,
                height: gorasize
            })
            
            drawCircle({
                pos: gameoverenemypos,
                radius: gameoverenemysize*.8,
                color: rgb(0, 0, 0),
            })
    
            drawText({
        		text: score,
                font: "sink",
        		pos: vec2(width()*.5, height()*.25),
        		origin: "center",
                size: scoreboard.size*.25,
                color: rgb(0, 0, 0),
                opacity: scoreopacity
    	    })
            drawRect({
                pos: vec2(0, height()*.33),
                width: width(),
                height: 10,
                color: rgb(255, 255, 255),
            })
    
            if(scoreopacity < 1)
                scoreopacity += .01
    
        }
    
    })
})

go("sigil");

</script>

</body>

</html>